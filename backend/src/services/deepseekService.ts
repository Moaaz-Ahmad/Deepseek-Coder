import axios, { AxiosInstance } from 'axios';
import NodeCache from 'node-cache';
import { createLogger } from '../config/logger.js';

const logger = createLogger();

export interface CodeGenerationRequest {
  prompt: string;
  language: string;
  context?: string;
  difficulty: 'beginner' | 'intermediate' | 'advanced';
}

export interface CodeExplanationRequest {
  code: string;
  language: string;
  level: 'simple' | 'detailed' | 'expert';
}

export interface ErrorAnalysisRequest {
  error: string;
  code: string;
  language: string;
}

export interface CodeCompletionRequest {
  code: string;
  language: string;
  cursorPosition: number;
}

export class DeepseekService {
  private client: AxiosInstance;
  private cache: NodeCache;
  private apiKey: string;
  private isDevelopment: boolean;

  constructor() {
    this.apiKey = process.env.DEEPSEEK_API_KEY || '';
    this.isDevelopment = process.env.NODE_ENV === 'development';
    
    if (!this.apiKey && !this.isDevelopment) {
      throw new Error('DEEPSEEK_API_KEY environment variable is required');
    }

    this.client = axios.create({
      baseURL: 'https://api.deepseek.com/v1',
      headers: {
        'Authorization': `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json'
      },
      timeout: 30000
    });

    // Cache for 5 minutes to reduce API calls
    this.cache = new NodeCache({ stdTTL: 300 });
  }

  async generateCode(request: CodeGenerationRequest): Promise<Record<string, unknown>> {
    const cacheKey = `generate:${JSON.stringify(request)}`;
    const cached = this.cache.get(cacheKey) as Record<string, unknown>;
    if (cached) {
      logger.info('Returning cached code generation result');
      return cached;
    }

    // Return mock response in development mode without API key
    if (this.isDevelopment && !this.apiKey) {
      logger.info('Returning mock code generation result (development mode)');
      const mockResponse = {
        generated_code: `// Generated ${request.language} code for: ${request.prompt}
// This is a mock response for development
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // TODO: Implement ${request.prompt}
        Log.d("AgentAI", "Activity created for: ${request.prompt}")
    }
}`,
        explanation: `This is a mock generated Android ${request.language} code for "${request.prompt}". In production, this would be generated by Deepseek AI with proper implementation details for ${request.difficulty} level developers.`,
        best_practices: [
          'Add proper error handling',
          'Implement data binding',
          'Add unit tests',
          'Follow Android best practices'
        ]
      };
      this.cache.set(cacheKey, mockResponse);
      return mockResponse;
    }

    const systemPrompt = this.getSystemPrompt(request.difficulty, 'generation');
    const userPrompt = this.buildGenerationPrompt(request);

    try {
      const response = await this.client.post('/chat/completions', {
        model: 'deepseek-coder',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        temperature: 0.3,
        max_tokens: 2000
      });

      const result = {
        code: this.extractCodeFromResponse(response.data.choices[0].message.content),
        explanation: this.extractExplanationFromResponse(response.data.choices[0].message.content),
        suggestions: this.extractSuggestionsFromResponse(response.data.choices[0].message.content)
      };

      this.cache.set(cacheKey, result);
      return result;
    } catch (error) {
      logger.error('Deepseek API error:', error);
      
      // Fall back to mock response if API fails
      logger.info('Falling back to mock code generation response');
      const mockResponse = {
        code: `// Generated ${request.language} code for: ${request.prompt}
// This is a fallback mock response due to API error
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        // TODO: Implement ${request.prompt}
        Log.d("AgentAI", "Activity created for: ${request.prompt}")
    }
}`,
        explanation: `This is a fallback mock response for "${request.prompt}". The Deepseek API is currently unavailable. In production with valid API access, this would be generated by Deepseek AI with proper implementation details for ${request.difficulty} level developers.`,
        suggestions: [
          'Add proper error handling',
          'Implement data binding',
          'Add unit tests',
          'Follow Android best practices'
        ]
      };
      this.cache.set(cacheKey, mockResponse);
      return mockResponse;
    }
  }

  async explainCode(request: CodeExplanationRequest): Promise<Record<string, unknown>> {
    const cacheKey = `explain:${JSON.stringify(request)}`;
    const cached = this.cache.get(cacheKey) as Record<string, unknown> | undefined;
    if (cached) {
      logger.info('Returning cached code explanation');
      return cached;
    }

    const systemPrompt = this.getSystemPrompt('beginner', 'explanation');
    const userPrompt = `Please explain this ${request.language} code in a ${request.level} way that a beginner can understand:\n\n\`\`\`${request.language}\n${request.code}\n\`\`\``;

    try {
      const response = await this.client.post('/chat/completions', {
        model: 'deepseek-coder',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        temperature: 0.2,
        max_tokens: 1500
      });

      const result = {
        explanation: response.data.choices[0].message.content,
        keyPoints: this.extractKeyPoints(response.data.choices[0].message.content),
        relatedConcepts: this.extractRelatedConcepts(response.data.choices[0].message.content)
      };

      this.cache.set(cacheKey, result);
      return result;
    } catch (error) {
      logger.error('Deepseek API error:', error);
      throw new Error('Failed to explain code');
    }
  }

  async analyzeError(request: ErrorAnalysisRequest): Promise<Record<string, unknown>> {
    const systemPrompt = `You are an expert Android developer helping beginners fix their code errors. 
    Provide clear, actionable solutions with examples. Focus on explaining WHY the error occurred and HOW to fix it.`;
    
    const userPrompt = `I'm getting this error in my ${request.language} code:

Error: ${request.error}

Code:
\`\`\`${request.language}
${request.code}
\`\`\`

Please help me understand and fix this error. Provide:
1. What caused the error (in simple terms)
2. How to fix it
3. The corrected code
4. Tips to avoid this error in the future`;

    try {
      const response = await this.client.post('/chat/completions', {
        model: 'deepseek-coder',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        temperature: 0.1,
        max_tokens: 2000
      });

      const content = response.data.choices[0].message.content;
      
      return {
        analysis: content,
        fixedCode: this.extractCodeFromResponse(content),
        prevention: this.extractPreventionTips(content)
      };
    } catch (error) {
      logger.error('Deepseek API error:', error);
      throw new Error('Failed to analyze error');
    }
  }

  async getCodeCompletion(request: CodeCompletionRequest): Promise<Record<string, unknown>> {
    const beforeCursor = request.code.substring(0, request.cursorPosition);
    const afterCursor = request.code.substring(request.cursorPosition);

    const systemPrompt = `You are an AI code completion assistant for Android development. 
    Provide smart, context-aware completions for ${request.language} code.`;
    
    const userPrompt = `Complete this ${request.language} code:

\`\`\`${request.language}
${beforeCursor}<CURSOR>${afterCursor}
\`\`\`

Provide relevant completions based on the context.`;

    try {
      const response = await this.client.post('/chat/completions', {
        model: 'deepseek-coder',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        temperature: 0.2,
        max_tokens: 500
      });

      return {
        completions: this.extractCompletions(response.data.choices[0].message.content)
      };
    } catch (error) {
      logger.error('Deepseek API error:', error);
      throw new Error('Failed to get code completion');
    }
  }

  private getSystemPrompt(difficulty: string, type: string): string {
    const basePrompt = `You are an expert Android developer and teacher specializing in helping ${difficulty} developers.`;
    
    switch (type) {
      case 'generation':
        return `${basePrompt} Generate clean, well-commented Android code that follows best practices. 
        Always include explanations for complex concepts and provide beginner-friendly alternatives when possible.`;
      case 'explanation':
        return `${basePrompt} Explain code in a clear, educational manner. 
        Use simple language and provide examples. Break down complex concepts into digestible parts.`;
      default:
        return basePrompt;
    }
  }

  private buildGenerationPrompt(request: CodeGenerationRequest): string {
    let prompt = `Generate ${request.language} code for: ${request.prompt}`;
    
    if (request.context) {
      prompt += `\n\nContext: ${request.context}`;
    }
    
    prompt += `\n\nRequirements:
- Target difficulty: ${request.difficulty} level
- Include helpful comments
- Follow Android best practices
- Provide a brief explanation of how it works`;

    return prompt;
  }

  private extractCodeFromResponse(response: string): string {
    const codeMatch = response.match(/```[\w]*\n([\s\S]*?)\n```/);
    return codeMatch?.[1] || '';
  }

  private extractExplanationFromResponse(response: string): string {
    // Extract explanation from response (implementation depends on response format)
    return response.split('```')[0]?.trim() || '';
  }

  private extractSuggestionsFromResponse(_response: string): string[] {
    // Extract suggestions from response
    return [];
  }

  private extractKeyPoints(_response: string): string[] {
    // Extract key points from explanation
    return [];
  }

  private extractRelatedConcepts(_response: string): string[] {
    // Extract related concepts
    return [];
  }

  private extractPreventionTips(_response: string): string[] {
    // Extract prevention tips from error analysis
    return [];
  }

  private extractCompletions(_response: string): string[] {
    // Extract code completions
    return [];
  }
}
